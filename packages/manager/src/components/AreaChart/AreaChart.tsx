import { Box, Paper } from '@linode/ui';
import { Typography, useTheme } from '@mui/material';
import { styled } from '@mui/material/styles';
import { DateTime } from 'luxon';
import React from 'react';
import {
  AreaChart as _AreaChart,
  Area,
  Brush,
  CartesianGrid,
  Legend,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from 'recharts';

import { AccessibleAreaChart } from 'src/components/AreaChart/AccessibleAreaChart';
import MetricsDisplay from 'src/components/LineGraph/MetricsDisplay';
import { StyledBottomLegend } from 'src/features/NodeBalancers/NodeBalancerDetail/NodeBalancerSummary/TablesPanel';

import {
  generate12HourTicks,
  humanizeLargeData,
  tooltipLabelFormatter,
  tooltipValueFormatter,
} from './utils';

import type { TooltipProps } from 'recharts';
import type { MetricsDisplayRow } from 'src/components/LineGraph/MetricsDisplay';

export interface DataSet {
  [label: string]: number;
  timestamp: number;
}

export type ChartVariant = 'area' | 'line';

export interface AreaProps {
  /**
   * color for the area
   */
  color: string;

  /**
   * datakey for the area
   */
  dataKey: string;
}

interface XAxisProps {
  /**
   * format for the x-axis timestamp
   * ex: 'hh' to convert timestamp into hour
   */
  tickFormat: string;

  /**
   * represents the pixel gap between two x-axis ticks
   */
  tickGap: number;
}

interface YAxisProps {
  /**
   * The formatter function for the y-axis tick.
   */
  tickFormat: (value: number) => string;
}

export interface AreaChartProps {
  /**
   * list of areas to be displayed
   */
  areas: AreaProps[];

  /**
   * aria-label for the graph
   */
  ariaLabel: string;

  /**
   * connect nulls value between two data points
   */
  connectNulls?: boolean;

  /**
   * data to be displayed on the graph
   */
  data: any;

  /**
   * radius of the dots to be displayed
   */
  dotRadius?: number;

  /**
   *
   */
  fillOpacity?: number;

  /**
   * The height of chart container.
   */
  height?: number;

  /**
   * Sets the height of the legend. Overflow scroll if the content exceeds the height.
   */
  legendHeight?: string;

  /**
   * list of legends rows to be displayed
   */
  legendRows?: Omit<MetricsDisplayRow[], 'handleLegendClick'>;

  /**
   * The sizes of whitespace around the container.
   */
  margin?: { bottom: number; left: number; right: number; top: number };

  /**
   * control the visibility of dots for each data points
   */
  showDot?: boolean;

  /**
   * true to display legends rows else false to hide
   * @default false
   */
  showLegend?: boolean;

  /**
   * timezone for the timestamp of graph data
   */
  timezone: string;

  /**
   * unit to be displayed with data
   */
  unit: string;

  /**
   * make chart appear as a line or area chart
   * @default area
   */
  variant?: ChartVariant;

  /**
   * The width of chart container.
   */
  width?: number;

  /**
   * x-axis properties
   */
  xAxis: XAxisProps;

  /**
   * number of x-axis ticks should be shown
   * 0 or undefined : ticks will be generated by recharts
   * non-zero value : this many ticks will be generated based on the starting & ending timestamp in the data
   */
  xAxisTickCount?: number;

  /**
   * y-axis properties
   */
  yAxisProps?: YAxisProps;

  resetZoom?: boolean;
}

export const AreaChart = (props: AreaChartProps) => {
  const {
    areas,
    ariaLabel,
    connectNulls,
    data,
    dotRadius = 3,
    fillOpacity,
    height = '100%',
    legendHeight,
    legendRows,
    margin = { bottom: 0, left: -20, right: 30, top: 0 },
    showDot,
    showLegend,
    timezone,
    unit,
    variant,
    width = '100%',
    xAxis,
    xAxisTickCount,
    yAxisProps,
  } = props;

  const theme = useTheme();
  const [xDomain, setXDomain] = React.useState<[number, number]>(
    data && data.length > 0
      ? [data[0].timestamp, data[data.length - 1].timestamp]
      : [0, 0]
  );

  const [chartData, setChartData] = React.useState<any[]>(data);

  const handleZoom = (event: React.WheelEvent) => {
    event.preventDefault();
    const zoomFactor = 0.1; // Adjust this value for faster/slower zoom
    const range = xDomain[1] - xDomain[0];
    const midpoint = xDomain[0] + range / 2;

    if (event.deltaY < 0) {
      // Zoom in
      setXDomain([
        midpoint - (range * (1 - zoomFactor)) / 2,
        midpoint + (range * (1 - zoomFactor)) / 2,
      ]);
    } else if (event.deltaY > 0) {
      // Zoom out
      setXDomain([
        midpoint - (range * (1 + zoomFactor)) / 2,
        midpoint + (range * (1 + zoomFactor)) / 2,
      ]);
    }
  };

  const [activeSeries, setActiveSeries] = React.useState<Array<string>>([]);
  const handleLegendClick = (dataKey: string) => {
    if (activeSeries.includes(dataKey)) {
      setActiveSeries(activeSeries.filter((el) => el !== dataKey));
    } else {
      setActiveSeries((prev) => [...prev, dataKey]);
    }
  };

  const xAxisTickFormatter = (timestamp: number) => {
    return DateTime.fromMillis(timestamp, { zone: timezone }).toFormat(
      xAxis.tickFormat
    );
  };

  // Handle the brush change and adjust the displayed chart data
  const handleBrushChange = (e: any) => {
    if (e && e.startIndex !== undefined && e.endIndex !== undefined) {
      const newStartIndex = e.startIndex;
      const newEndIndex = e.endIndex;

      // Update the brush range
      const startTimestamp = data[newStartIndex].timestamp;
      const endTimestamp = data[newEndIndex].timestamp;

      if (
        startTimestamp &&
        endTimestamp &&
        !(xDomain[0] === startTimestamp && xDomain[1] === endTimestamp)
      ) {
        // Slice the chartData based on the brush range
        const newChartData = data.slice(newStartIndex, newEndIndex + 1);
        setXDomain([startTimestamp, endTimestamp]);
        setChartData(newChartData);
      }
    }
  };

  const CustomTooltip = ({
    active,
    label,
    payload,
  }: TooltipProps<any, any>) => {
    if (active && payload && payload.length) {
      return (
        <StyledTooltipPaper>
          <Typography>{tooltipLabelFormatter(label, timezone)}</Typography>
          {payload.map((item) => (
            <Box
              display="flex"
              justifyContent="space-between"
              key={item.dataKey}
            >
              <Typography fontFamily={theme.font.bold}>
                {item.dataKey}
              </Typography>
              <Typography fontFamily={theme.font.bold} marginLeft={2}>
                {tooltipValueFormatter(item.value, unit)}
              </Typography>
            </Box>
          ))}
        </StyledTooltipPaper>
      );
    }

    return null;
  };

  const CustomLegend = ({ legendHeight }: { legendHeight?: string }) => {
    if (legendRows) {
      const legendRowsWithClickHandler = legendRows.map((legendRow) => ({
        ...legendRow,
        handleLegendClick: () => handleLegendClick(legendRow.legendTitle),
      }));

      return (
        <StyledBottomLegend>
          <MetricsDisplay
            hiddenRows={activeSeries}
            legendHeight={legendHeight}
            rows={legendRowsWithClickHandler}
          />
        </StyledBottomLegend>
      );
    }
    return null;
  };

  const accessibleDataKeys = areas.map((area) => area.dataKey);

  const legendStyles = {
    bottom: 0,
    left: 0,
    width: '100%',
  };

  return (
    <div onWheel={handleZoom}>
      <ResponsiveContainer height={height} width={width}>
        <_AreaChart aria-label={ariaLabel} data={data} margin={margin}>
          <CartesianGrid
            stroke={theme.color.grey7}
            strokeDasharray="3 3"
            vertical={false}
          />
          <XAxis
            ticks={
              xAxisTickCount
                ? generate12HourTicks(chartData, timezone, xAxisTickCount)
                : []
            }
            dataKey="timestamp"
            domain={xDomain}
            interval={xAxisTickCount ? 0 : 'preserveEnd'}
            minTickGap={xAxis.tickGap}
            scale="time"
            stroke={theme.color.label}
            tickFormatter={xAxisTickFormatter}
            type="number"
          />
          <YAxis
            tickFormatter={
              yAxisProps?.tickFormat ? yAxisProps.tickFormat : humanizeLargeData
            }
            stroke={theme.color.label}
          />
          <Tooltip
            contentStyle={{
              color: theme.tokens.color.Neutrals[70],
            }}
            itemStyle={{
              color: theme.tokens.color.Neutrals[70],
              fontFamily: theme.font.bold,
            }}
            content={<CustomTooltip />}
          />
          {showLegend && !legendRows && (
            <Legend
              formatter={(value) => (
                <span style={{ color: theme.color.label, cursor: 'pointer' }}>
                  {value}
                </span>
              )}
              onClick={({ dataKey }) => {
                if (dataKey) {
                  handleLegendClick(dataKey as string);
                }
              }}
              iconType="square"
              wrapperStyle={legendStyles}
            />
          )}
          {showLegend && legendRows && (
            <Legend
              content={<CustomLegend legendHeight={legendHeight} />}
              wrapperStyle={legendStyles}
            />
          )}
          {areas.map(({ color, dataKey }) => (
            <Area
              connectNulls={connectNulls}
              dataKey={dataKey}
              dot={{ r: showDot ? dotRadius : 0 }}
              fill={color}
              fillOpacity={variant === 'line' ? 0 : fillOpacity ?? 1}
              hide={activeSeries.includes(dataKey)}
              isAnimationActive={false}
              key={dataKey}
              stroke={color}
              type="monotone"
            />
          ))}
          <Brush
            dataKey="timestamp"
            fill="rgba(76, 175, 80, 0.2)" // Light green semi-transparent background
            height={10} // Increase the height for a better visual
            onChange={handleBrushChange}
            stroke="#4CAF50" // Stylish green stroke
            tickFormatter={xAxisTickFormatter}
            travellerWidth={15} // Wider handles
          />
        </_AreaChart>
      </ResponsiveContainer>
      <AccessibleAreaChart
        ariaLabel={ariaLabel}
        data={data}
        dataKeys={accessibleDataKeys}
        timezone={timezone}
        unit={unit}
      />
    </div>
  );
};

const StyledTooltipPaper = styled(Paper, {
  label: 'StyledTooltipPaper',
})(({ theme }) => ({
  border: `1px solid ${theme.color.border2}`,
  padding: theme.spacing(1),
}));

// const StylishBrush = ({ data, handleBrushChange, xAxisTickFormatter }) => {
//   return (
//     <Brush
//       dataKey="timestamp"
//       endIndex={data.length - 1} // Ensure full range is included
//       fill="rgba(76, 175, 80, 0.2)" // Light green semi-transparent background
//       height={40} // Increase the height for a better visual
//       onChange={handleBrushChange}
//       startIndex={0} // Set initial visible range
//       stroke="#4CAF50" // Stylish green stroke
//       tickFormatter={xAxisTickFormatter} // Format the displayed timestamps
//       travellerWidth={12} // Wider handles
//     >
//       <text
//         style={{
//           fill: '#4CAF50',
//           fontSize: 12,
//           fontWeight: 600,
//         }}
//         x={0}
//         y={20}
//       >
//         Drag to filter the range
//       </text>
//     </Brush>
//   );
// };
